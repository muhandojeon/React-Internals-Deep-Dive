# 2 - Initial Mount, how does it work?

> [!IMPORTANT]
> - 리액트가 어떻게 초기 마운트(첫 렌더링) 하는지
> - 리액트가 어떻게 DOM을 구성하는지

## 1. Fiber Architecture에 대한 소개

- 리액트는 v16부터 Fiber라는 새로운 코어 아키텍처 채택 (stack reconciler → fiber reconciler)
- Fiber는 리액트가 state를 유지하는 방식을 나타내는 아키텍처
- `FiberRootNode`와 `FiberNodes`로 구성된 트리형 구조
- 리액트 런타임은 Fiber Tree를 유지/업데이트하고, 최소한의 업데이트로 host DOM을 동기화
 
### 1.1 FiberRootNode

- **리액트 루트 역할을 하는 노드**
- 전체 앱에 대한 메타 정보를 가지고 있음
- `current`는 실제 Fiber Tree를 가리킴
- 새로운 Fiber Tree가 구성될 때마다 `current`는 새로운 `HostRoot`를 가리킴

### 1.2 FiberNode

`FiberRootNode`를 제외한 모든 노드가 `FiberNode`
  
| FiberNode 속성 | 설명 |
| :-: | :-: |
| `tag` | `tag`를 통해 `FiberNode`를 sub type으로 구분 |
| `stateNode` | backing data를 가리킴 |
| `child`, `sibiling`, `return` | 이런 속성들이 모여 트리 구조 형성 |
| `elementType` | component function 혹은 내장 HTML 태그 |
| `flags` | 커밋 단계에서 적용할 업데이트 |
| `lanes` | 보류 중인 업데이트의 우선 순위 |
| `memoizedState` | 중요 데이터를 가리킴 (함수형 컴포넌트의 경우 훅을 의미) |
 
## 2. Trigger 단계에서의 초기 마운트

`createRoot()`는 `createFiberRoot()`를 호출하여  
리액트 루트 역할을 하는 노드인 `FiberRootNode`를 생성함 = React root를 생성함

[코드](https://github.com/facebook/react/blob/9eabb37338e6bea18441dec58a4284fe00ee09ae/packages/react-dom/src/client/ReactDOMRoot.js#L224-L246)

## 3. Render 단계에서의 초기 마운트

### 3.1 performConcurrentWorkOnRoot()

`performConcurrentWorkOnRoot()`는 초기 마운트 및 리렌더링 진입점

이름에 `concurrent`가 있지만, 내부적으로 필요할 때 `sync` 모드로 동작함  
초기 마운트의 경우, concurrent 모드가 실제로 사용되지 않을 수도 있음  

```js
let exitStatus = shouldTimeSlice
  ? renderRootConcurrent(root, lanes)
  : renderRootSync(root, lanes);
```

>| 구분 | synchronous 모드 | concurrent 모드 |
>| :-: | :-: | :-: |
>| 실행 방식 | 한 번에 연속적으로 실행 | 작업을 나누어 중단/재개 |
>| 렌더링 특성 | 렌더링 시작 시 완료까지 중단 불가 | 우선순위에 따라 렌더링 조절 가능 |
>| 메인 스레드 | 차단됨 | 차단되지 않음 |
>| 사용자 경험 | 대규모 업데이트 시 UI 끊김 현상 발생 | 부드러운 UI 업데이트 제공 |
>| 핵심 기능 | 일반적인 상태 업데이트 (setState) | - startTransition<br>- useDeferredValue<br>- Suspense |

### 3.2 renderRootSync()

![image](https://github.com/user-attachments/assets/852f97cc-1b32-4b93-8be1-b73790467a9f)

`renderRootSync()`는 Double Buffering 구조 만드는 역할
> [Double Buffering 구조 설명 참고](https://sckimynwa.medium.com/react-mount-system-deep-dive-sync-mode-c89c1ace14af)

내부는 단순한 `while` 루프

```js
function workLoopSync() {
  // workInProgress가 있으면 계속 performUnitOfWork() 수행
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
```

- `current` : UI에 그려진 현재 버전
- `workInProgress` : 구축 중이며 다음 current로 사용될 버전

### 3.3 performUnitOfWork()

재조정자는 `FiberNode`를 하나의 작업 단위, `unitOfWork`로 취급  
`FiberNode`는 렌더링에 필요한 정보를 담고 있는 객체이자 재조정 작업 단위  
`FiberNode`를 작업 단위로 처리하는 함수 = `performUnitOfWork()`  

`beginWork()`는 `performUnitOfWork()` 내부에서 호출되며, 실제 렌더링이 발생하는 곳

```ts
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  if (current !== null) { // current가 null이 아니라면, 초기 마운트가 아님
    ...
  } else {
    didReceiveUpdate = false; // current가 null이면 초기 마운트라서 업데이트가 없음
  }
  // 타입마다 다르게 처리
  switch (workInProgress.tag) {
    case IndeterminateComponent:
    case FunctionComponent:
    case HostRoot:
    case HostComponent:
    case HostText:
    case SuspenseComponent:
    // 더 많은 타입들이 존재
  }
}
```

### 3.4 prepareFreshStack()

`renderRootSync()` → `prepareFreshStack()` → `createWorkInProgress()` 호출  

새로운 렌더링이 시작될 때마다 current HostRoot에서 새로운 `workInProgress` 생성 = 새로운 Fiber Tree의 root 역할  
`beginWork()`의 분기들에서 `HostRoot`로 가게 되고, 다음 단계는 `updateHostRoot()`가 된다.

### 3.5 updateHostRoot()

reconciling 이후에 `workInProgress`에 대한 새로운 자식 생성  
`workLoopSync()`가 이어서 처리할 예정

### 3.6 reconcileChildren()

> [!IMPORTANT]
> React 내부에서 매우 중요한 함수

new children을 old children과 비교하고, `workInProgress`에 `child` 설정
