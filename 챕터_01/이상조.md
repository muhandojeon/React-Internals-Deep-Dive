**# React는 내부적으로 어떻게 동작하나요? React 내부 구조 개요

React Internals Deep Dive 시리즈의 에피소드 1입니다. YouTube에서 제가 설명하는 것을 시청하실 수 있습니다.
React@18.2.0 기준이며, 최신 버전에서는 구현이 변경되었을 수 있습니다.

더 나은 React 코드를 작성하기 위해 React 내부 구조에 대해 더 알고 싶지만, 시작하기가 어렵고 어디서부터 시작해야 할지 모르실 것입니다. 마치 깊고 넓은 물에 뛰어들고 싶지만 망설여지는 것처럼요.

저도 2021년에 정확히 같은 고민을 했지만, React가 내부적으로 어떻게 작동하는지 설명하는 30개 이상의 에피소드로 구성된 'React Internals Deep Dive' 시리즈를 만들어냈습니다.

이 첫 번째 에피소드에서는 React 내부 구조의 대략적인 개요와 React 내부를 학습하는 방법에 대한 팁을 알려드리겠습니다.

## 1. React 내부 학습을 위한 팁

### 1.1 공식 자료 이해하기

[React.dev](https://react.dev/)는 React API를 배우는 것뿐만 아니라 React 코어 팀의 생각을 배울 수 있는 훌륭한 곳입니다. 그들이 왜 그러한 선택을 했는지에 대해 많은 설명을 해두었습니다.

[React Working Group](https://github.com/reactwg)은 새로운 아이디어들을 논의하는 공간입니다.

### 1.2 React 팀 팔로우하기

React 팀이 무엇을 하고 있는지 계속 업데이트 받으려면 모든 [리스트된 멤버들](https://react.dev/community/team)을 팔로우하세요. 인터넷상의 그들의 토론은 코드에서는 찾을 수 없는 독특한 관점을 제공합니다.

### 1.3 React 저장소 팔로우하기

[Github의 React 저장소](https://github.com/facebook/react)는 코드뿐만 아니라 PR과 코드 리뷰도 볼 수 있는 곳입니다. 대부분의 경우 코드의 주석보다 더 나은 설명이 담겨있습니다.

### 1.4 코드를 신뢰하고, 게시물은 신뢰하지 마세요

인터넷에는 React 내부에 대한 많은 글들이 있지만, 도움이 되는 것은 거의 없습니다. 대부분은 코드를 다루지 않고 일반적인 아이디어만 설명하고 있어서, 읽고 나서도 React 퀴즈를 풀 수 없기 때문에 가치가 떨어집니다.

시간이 있다면 React 소스 코드를 살펴보세요. 확실히 도움이 될 것입니다.

### 1.5 핵심 경로 찾기

하지만 React 코드베이스는 거대하고 위압적입니다. 제가 실제로 했고 추천하는 방법은 '**핵심 경로를 찾는 것**'입니다 - 모든 것을 한 번에 이해할 필요는 없습니다. 어떤 것이 어떻게 작동하는지 대략적인 아이디어를 가지고, 퍼즐을 하나씩 해결하면서 이해의 네트워크를 형성해 나가는 것이 좋습니다.

디버깅 비디오를 만든 지 2년이 지나서야 이 첫 번째 개요 에피소드를 완성할 수 있었던 이유가 바로 이것입니다. 작은 퍼즐들을 해결하는 데 모든 시간을 보냈고, 이제야 큰 그림을 설명하는 것이 편안해졌기 때문입니다.

## 2. **breakpoints**로 React 내부 구조를 디버깅하는 방법

### 2.1 **breakpoints** 설정하기

아래는 디버깅 과정을 설명하기 위해 사용할 코드입니다.

```jsx
function App() {
  const [count, setCount] = useState(1);
  debugger; // 이 debugger는 컴포넌트가 실행될 때를 알려줍니다

  useEffect(() => {
    debugger; // 이 debugger는 effect 훅이 실행될 때를 알려줍니다
    setCount((count) => count + 1);
  }, []);

  return <button>{count}</button>;
}

ReactDOM.createRoot(document.getElementById("container")).render(<App />);
```

React는 UI 라이브러리이므로, DOM이 조작되는 코드를 찾는 것이 중요한 작업입니다. 그러면 콜 스택을 읽어서 무슨 일이 일어나고 있는지 파악할 수 있습니다. 여기서는 DOM 컨테이너에 DOM breakpoint를 생성하면 됩니다.

### 2.2 첫 번째 일시 중지: 컴포넌트 렌더링

콜 스택에서 중요한 함수들은 다음과 같습니다:

- `ReactDOMRoot.render()` → 우리가 작성하는 사용자 측 코드로, createRoot()를 하고 render()를 합니다
- `scheduleUpdateOnFiber()` → React에게 어디를 렌더링할지 알려줍니다. 초기 마운트에서는 이전 버전이 없으므로 root에서 호출됩니다
- `ensureRootIsScheduled()` → performConcurrentWorkOnRoot()가 스케줄링되도록 "보장"하는 중요한 호출입니다
- `scheduleCallback()` → 실제 스케줄링으로, React Scheduler의 일부입니다. postMessage()로 비동기 처리됩니다
- `workLoop()` → React Scheduler가 작업을 처리하는 방식입니다
- `performConcurrentWorkOnRoot()` → 스케줄링된 작업이 실행되며, 여기서 우리의 컴포넌트가 실제로 렌더링됩니다

이를 통해 React가 실제로 렌더링을 어떻게 수행하는지에 대한 단서를 얻을 수 있습니다.

### 2.3 두 번째 일시 중지: DOM 조작

UI 라이브러리로서의 목표는 DOM 업데이트를 관리하는 것입니다. 이는 실제로 이전 "렌더" 단계 이후의 "커밋" 단계에서 이루어집니다.

- `commitRoot()` → 이전 렌더 단계에서 도출된 필요한 DOM 업데이트를 커밋합니다. 물론 effect 처리와 같은 다른 작업도 수행합니다
- `commitMutationEffects()` → 실제 호스트 DOM 업데이트입니다

## 2.4 세 번째 일시 중지: effect 실행

이제 useEffect() 호출에서 일시 중지되는 것을 볼 수 있습니다.

- `flushPassiveEffects()` → 모든 패시브 effect를 플러시합니다. useEffect()로 생성된 것들입니다.

postMessage()로 비동기 처리되는 것을 주목하세요. 즉시 실행되지 않고 스케줄링된다는 의미입니다. flushPassiveEffects()에 브레이크포인트를 추가하면 이것이 commitRoot() 내부에 있다는 것을 쉽게 알 수 있습니다.

### 2.5 컴포넌트 렌더링에서 다시 일시 중지

useEffect() 내에서 setState()를 호출하여 재렌더링을 트리거하면, 콜 스택에서 첫 번째 브레이크포인트 일시 중지와 매우 유사한 전체 재렌더링 과정을 볼 수 있습니다. 단, performConcurrentWorkOnRoot() 내부에서는 mountIndeterminateComponent() 대신 updateFunctionComponent()가 호출됩니다.

React 소스 코드에서 mount는 초기 렌더링을 의미합니다. 초기 렌더링에서는 비교할 이전 버전이 없기 때문입니다.

## 3. React 내부 구조의 개요

실제로 위의 스크린샷들은 이미 React 내부의 기본 사항들을 다루고 있습니다. 개요로서 너무 자세한 내용은 다루지 않겠지만, 이미 세부 사항을 파악했기 때문에 React 내부 구조를 아래와 같이 4단계로 나누어 설명하겠습니다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/0a311d39-d3ee-4b1e-9dff-35efa4783ccc/1df5d15a-daa7-4ab9-af69-74b6044dc837/image.png)

### 3.1 트리거(Trigger)

모든 작업이 여기서 시작되기 때문에 "트리거"라고 이름 붙였습니다. 초기 마운트든 state 훅으로 인한 재렌더링이든 상관없습니다. 이 단계에서는 React 런타임에 앱의 어느 부분을 렌더링해야 하는지(scheduleUpdateOnFiber())와 어떻게 수행해야 하는지를 알려줍니다.

이 단계를 "**작업 생성**"이라고 생각할 수 있습니다. ensureRootIsScheduled()는 그러한 작업을 생성하는 마지막 단계이며, 이후 작업은 scheduleCallback()을 통해 스케줄러로 전송됩니다.

관련 주제는 다음을 참조하세요:

- useState()는 React 내부적으로 어떻게 작동하나요?

### 3.2 스케줄(Schedule)

이것은 React Scheduler로, 기본적으로 **우선순위에 따라 작업을 처리**하는 우선순위 큐입니다. scheduleCallback()은 렌더링이나 effect 실행과 같은 작업을 스케줄링하기 위해 런타임 코드에서 호출됩니다. Scheduler 내부의 workLoop()는 작업이 실제로 실행되는 방식입니다.

Scheduler에 대한 자세한 내용은 다음을 참조하세요:

- React Scheduler는 어떻게 작동하나요?

### 3.3 렌더(Render)

렌더는 **스케줄링된 작업**(performConcurrentWorkOnRoot())입니다. 이는 **새로운 Fiber 트리를 계산**하고 호스트 **DOM에 적용해야 할 업데이트를 파악하는 것**을 의미합니다.

여기서는 Fiber 트리의 세부 사항을 알 필요는 없습니다. 이는 기본적으로 앱의 현재 상태를 나타내는 내부 트리 구조입니다. 이전에는 Virtual DOM이라고 불렸지만, 이제는 DOM만을 위한 것이 아니기 때문에 React 팀은 더 이상 Virtual DOM이라고 부르지 않습니다.

따라서 performConcurrentWorkOnRoot()는 트리거 단계에서 생성되고, 스케줄러에서 우선순위가 정해진 다음, 여기서 실제로 실행됩니다. 마치 작은 사람이 Fiber 트리를 돌아다니면서 재렌더링이 필요한지 확인하고 호스트 DOM에 필요한 업데이트를 파악하는 것처럼 생각하면 됩니다.

**동시성 모드 때문에 "렌더" 단계는 중단되고 재개될 수 있어서 매우 복잡한 단계가 됩니다.**

자세한 내용은 다음 에피소드를 참조하세요:

- React는 내부적으로 Fiber 트리를 어떻게 순회하나요?
- React의 bailout은 재조정 과정에서 어떻게 작동하나요?
- 'key'는 내부적으로 어떻게 작동하나요? React의 리스트 비교
- React 소스 코드에서 Lanes는 무엇인가요?

### 3.4 커밋(Commit)

**새로운 Fiber 트리가 구성되고 최소한의 업데이트가 도출되면, 이제 업데이트를 호스트 DOM에 "커밋"할 차례입니다.**

물론 DOM을 조작하는 것(commitMutationEffects()) 외에도 더 많은 작업이 있습니다. 예를 들어, **모든 종류의 Effect가 여기서 처리**됩니다(flushPassiveEffects(), commitLayoutEffects()).

관련 에피소드:

- useLayoutEffect()는 내부적으로 어떻게 작동하나요?
- useEffect()는 React 내부에서 어떻게 작동하나요?
- useTransition()은 내부적으로 어떻게 작동하나요?
- React의 effect 훅의 생명주기

## 4. 요약

이것으로 React Internals Deep Dive의 첫 번째 에피소드를 마칩니다. 간단한 디버거 설정만으로도 얼마나 많은 정보를 얻을 수 있는지 보셨을 것입니다.

겁먹지 마시고 퍼즐을 하나씩 해결해 나가세요. 매일 React를 더 잘 이해하게 될 것입니다. 막히는 부분이 있다면 제 디스코드에서 연락해주세요.

이 글이 도움이 되었기를 바랍니다.**
